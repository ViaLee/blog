(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{386:function(e,t,s){e.exports=s.p+"assets/img/renderControl.09225c1d.png"},398:function(e,t,s){"use strict";s.r(t);var a=s(54),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[e._v("#")]),e._v(" React")]),e._v(" "),a("h2",{attrs:{id:"jsx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx"}},[e._v("#")]),e._v(" Jsx")]),e._v(" "),a("p",[e._v("react 中，经过 babel 编译--\x3eReact.createElement"),a("br"),e._v("\nReact DOM 在渲染所有输入内容之前，默认会进行转义，这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。")]),e._v(" "),a("h2",{attrs:{id:"渲染控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染控制"}},[e._v("#")]),e._v(" 渲染控制")]),e._v(" "),a("p",[a("img",{attrs:{src:s(386),alt:"RenderControl"}}),e._v("\n控制 render 的方法：")]),e._v(" "),a("ul",[a("li",[e._v("从父组件直接隔断子组件的渲染，经典的就是 memo，缓存 element 对象。")]),e._v(" "),a("li",[e._v("组件从自身来控制是否 render ，比如：PureComponent ，shouldComponentUpdate。")])]),e._v(" "),a("h3",{attrs:{id:"缓存-element-对象减少更新原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存-element-对象减少更新原理"}},[e._v("#")]),e._v(" 缓存 element 对象减少更新原理")]),e._v(" "),a("p",[e._v("每次 render 阶段，createElement 会创建一个新的 props(pendingProps)，react 对比 fiber 上的 pendingProps 和 oldProps，如果相等，则不更新。将 element 对象缓存起来，上面 props 也就和 fiber 上 oldProps 指向相同的内存空间，也就是相等。")]),e._v(" "),a("h3",{attrs:{id:"purecomponent"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent"}},[e._v("#")]),e._v(" PureComponent")]),e._v(" "),a("p",[e._v("浅比较 state 和 props 是否相等；\nshouldComponentUpdate 的权重，大于 PureComponent；\n更新阶段对 state 和 props 的比较，用了 "),a("em",[e._v("shallowEqual")]),e._v(" 函数：")]),e._v(" "),a("ol",[a("li",[e._v("判断新老 state/props 是否相等")]),e._v(" "),a("li",[e._v("新老 state/props 是否为非对象/null")]),e._v(" "),a("li",[e._v("新老 state/props 的 keys 长度是否相等")]),e._v(" "),a("li",[e._v("遍历老 state/props，对比对应新 state/props 的值是否相等")])]),e._v(" "),a("h3",{attrs:{id:"react-memo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-memo"}},[e._v("#")]),e._v(" React.memo")]),e._v(" "),a("p",[e._v("是一个高阶组件")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[e._v("React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("memo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("Component"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" compare"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// compare 返回true：缓存，false：更新")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// shouldComponentUpdate 返回true：更新，false：缓存")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// compare 不传->使用shallowEqual函数浅比较props")]),e._v("\n")])])]),a("h3",{attrs:{id:"强制重新渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强制重新渲染"}},[e._v("#")]),e._v(" 强制重新渲染")]),e._v(" "),a("ol",[a("li",[e._v("forceUpdate："),a("br"),e._v("\n如果组件调用 forceUpdate,则全局的 hasForceUpdate=true，组件更新前检查如果为 true，则跳过 PureComponent 的浅比较和 shouldComponentUpdate 自定义比较，直接更新")]),e._v(" "),a("li",[e._v("context 的更新")])]),e._v(" "),a("h3",{attrs:{id:"suspense"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#suspense"}},[e._v("#")]),e._v(" Suspense")]),e._v(" "),a("p",[e._v("Suspense 在执行内部可以通过 try{}catch{} 方式捕获异常，这个异常通常是一个 Promise ，可以在这个 Promise 中进行数据请求工作，Suspense 内部会处理这个 Promise ，Promise 结束后，Suspense 会再一次重新 render 把数据渲染出来，达到异步渲染的效果。")]),e._v(" "),a("h2",{attrs:{id:"hooks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[e._v("#")]),e._v(" Hooks")]),e._v(" "),a("h3",{attrs:{id:"usecallback-和-usememo-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usecallback-和-usememo-区别"}},[e._v("#")]),e._v(" useCallback 和 useMemo 区别")]),e._v(" "),a("p",[e._v("useCallback 缓存第一个参数；"),a("br"),e._v("\nuseMemo 执行第一个参数，缓存其结果。")])])}),[],!1,null,null,null);t.default=r.exports}}]);