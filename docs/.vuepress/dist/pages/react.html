<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | 💫Viaのblog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/babe.png">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.a509abab.css" as="style"><link rel="preload" href="/assets/js/app.6a1e7b57.js" as="script"><link rel="preload" href="/assets/js/2.f7f94fda.js" as="script"><link rel="preload" href="/assets/js/8.74f87bb3.js" as="script"><link rel="prefetch" href="/assets/js/10.94991a2c.js"><link rel="prefetch" href="/assets/js/11.dc2a681f.js"><link rel="prefetch" href="/assets/js/12.8ba7a12f.js"><link rel="prefetch" href="/assets/js/13.515533ed.js"><link rel="prefetch" href="/assets/js/14.45f6d6ea.js"><link rel="prefetch" href="/assets/js/15.a540c83c.js"><link rel="prefetch" href="/assets/js/16.01649045.js"><link rel="prefetch" href="/assets/js/17.49ac8e1a.js"><link rel="prefetch" href="/assets/js/18.2fc85019.js"><link rel="prefetch" href="/assets/js/19.eab16a2f.js"><link rel="prefetch" href="/assets/js/20.656e1424.js"><link rel="prefetch" href="/assets/js/21.d475564f.js"><link rel="prefetch" href="/assets/js/22.fbce710a.js"><link rel="prefetch" href="/assets/js/23.0e11ca0d.js"><link rel="prefetch" href="/assets/js/3.36e6c52f.js"><link rel="prefetch" href="/assets/js/4.dbbfc7ac.js"><link rel="prefetch" href="/assets/js/5.1efdb115.js"><link rel="prefetch" href="/assets/js/6.6feef2bf.js"><link rel="prefetch" href="/assets/js/7.4b590157.js"><link rel="prefetch" href="/assets/js/9.623af976.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a509abab.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/babe.png" alt="💫Viaのblog" class="logo"> <span class="site-name can-hide">💫Viaのblog</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Basic 🐳" class="dropdown-title"><span class="title">Basic 🐳</span> <span class="arrow down"></span></button> <button type="button" aria-label="Basic 🐳" class="mobile-dropdown-title"><span class="title">Basic 🐳</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/javascript.html" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/pages/react.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></li><li class="dropdown-item"><!----> <a href="/pages/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/pages/webpack.html" class="nav-link">
  Webpack
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Web 🌏" class="dropdown-title"><span class="title">Web 🌏</span> <span class="arrow down"></span></button> <button type="button" aria-label="Web 🌏" class="mobile-dropdown-title"><span class="title">Web 🌏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/pages/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/pages/browser.html" class="nav-link">
  浏览器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Blog ✍🏻" class="dropdown-title"><span class="title">Blog ✍🏻</span> <span class="arrow down"></span></button> <button type="button" aria-label="Blog ✍🏻" class="mobile-dropdown-title"><span class="title">Blog ✍🏻</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/interview.html" class="nav-link">
  面试 📖
</a></li><li class="dropdown-item"><!----> <a href="/pages/blog.html" class="nav-link">
  博客 ✍🏻
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Basic 🐳" class="dropdown-title"><span class="title">Basic 🐳</span> <span class="arrow down"></span></button> <button type="button" aria-label="Basic 🐳" class="mobile-dropdown-title"><span class="title">Basic 🐳</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/javascript.html" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/pages/react.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></li><li class="dropdown-item"><!----> <a href="/pages/css.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/pages/webpack.html" class="nav-link">
  Webpack
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Web 🌏" class="dropdown-title"><span class="title">Web 🌏</span> <span class="arrow down"></span></button> <button type="button" aria-label="Web 🌏" class="mobile-dropdown-title"><span class="title">Web 🌏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/http.html" class="nav-link">
  HTTP
</a></li><li class="dropdown-item"><!----> <a href="/pages/security.html" class="nav-link">
  安全
</a></li><li class="dropdown-item"><!----> <a href="/pages/browser.html" class="nav-link">
  浏览器
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Blog ✍🏻" class="dropdown-title"><span class="title">Blog ✍🏻</span> <span class="arrow down"></span></button> <button type="button" aria-label="Blog ✍🏻" class="mobile-dropdown-title"><span class="title">Blog ✍🏻</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/interview.html" class="nav-link">
  面试 📖
</a></li><li class="dropdown-item"><!----> <a href="/pages/blog.html" class="nav-link">
  博客 ✍🏻
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/react.html#jsx" class="sidebar-link">Jsx</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/react.html#react-createelement" class="sidebar-link">React.createElement</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#react-component" class="sidebar-link">React Component</a></li></ul></li><li><a href="/pages/react.html#children-相关-api" class="sidebar-link">Children 相关 API</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/react.html#单项数据流" class="sidebar-link">单项数据流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/react.html#生命周期" class="sidebar-link">生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/react.html#getsnapshotbeforeupdate" class="sidebar-link">getSnapshotBeforeUpdate</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#useeffect-和-uselayouteffect-和-componentdidmount" class="sidebar-link">useEffect 和 useLayoutEffect 和 componentDidMount</a></li></ul></li><li><a href="/pages/react.html#_15vs16" class="sidebar-link">15vs16</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/react.html#更新过程" class="sidebar-link">更新过程</a></li></ul></li><li><a href="/pages/react.html#fiber" class="sidebar-link">Fiber</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/react.html#fiber-节点-动态工作单元" class="sidebar-link">fiber 节点——动态工作单元</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#fiber-架构" class="sidebar-link">fiber 架构</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#首屏渲染、更新区别" class="sidebar-link">首屏渲染、更新区别</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#context" class="sidebar-link">Context</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#强制重新渲染" class="sidebar-link">强制重新渲染</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#suspense" class="sidebar-link">Suspense</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#dangerouslysetinnerhtml" class="sidebar-link">dangerouslySetInnerHTML</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#diff-算法" class="sidebar-link">diff 算法</a></li></ul></li><li><a href="/pages/react.html#hooks" class="sidebar-link">Hooks</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/react.html#代数效应" class="sidebar-link">代数效应</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#useeffect" class="sidebar-link">useEffect</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#usecallback-和-usememo-区别" class="sidebar-link">useCallback 和 useMemo 区别</a></li></ul></li><li><a href="/pages/react.html#react-中的性能优化" class="sidebar-link">React 中的性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/react.html#性能优化原则" class="sidebar-link">性能优化原则：</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#不使用-api" class="sidebar-link">不使用 api</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#相关-api" class="sidebar-link">相关 api</a></li><li class="sidebar-sub-header"><a href="/pages/react.html#渲染控制" class="sidebar-link">渲染控制</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" class="header-anchor">#</a> React</h1> <h2 id="jsx"><a href="#jsx" class="header-anchor">#</a> Jsx</h2> <p>react 中，经过 babel 编译--&gt;React.createElement(react 17 不需要显式导入 react)<br>
React DOM 在渲染所有输入内容之前，默认会进行转义，这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。<br>
可通过@babel/plugin-transform-react-jsx (opens new window)插件显式告诉 Babel 编译时需要将 JSX 编译为什么函数的调用（默认为 React.createElement）。</p> <h3 id="react-createelement"><a href="#react-createelement" class="header-anchor">#</a> React.createElement</h3> <p>createElement 方法会创建并返回一个对象，存放组件的信息，其$$typeof 为'REACT_ELEMENT_TYPE'<br>
React.isValidElement()检测是否为合法组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">isValidElement</span><span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> object <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">&amp;&amp;</span>
    object <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    object<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span> <span class="token operator">===</span> <span class="token constant">REACT_ELEMENT_TYPE</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="react-component"><a href="#react-component" class="header-anchor">#</a> React Component</h3> <p>区分函数组件和类组件：</p> <ol><li>XXX.prototype.isReactComponent 是否存在，存在————类组件，不存在————函数组件</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ClassComponent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isReactComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;ClassComponent是类组件&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;ClassComponent函数式组件&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>instanceof React.Component true————类组件，false————函数组件</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> clas <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">ClassComponent is Class  </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>clas <span class="token keyword">instanceof</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

<span class="token keyword">const</span> func <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FunctionComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">FunctionComponent is Class  </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>func <span class="token keyword">instanceof</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
</code></pre></div><h2 id="children-相关-api"><a href="#children-相关-api" class="header-anchor">#</a> Children 相关 API</h2> <p>React.isValidElement(item) 判断是否 react element
React.Children.only 子节点是否单一
React.Children.forEach 遍历子节点
React.Children.forEach = React.Children.toArray + Array.prototype.forEach</p> <blockquote><p>通常与 React.cloneElement()一起使用操作 children,注入新的属性</p></blockquote> <h2 id="单项数据流"><a href="#单项数据流" class="header-anchor">#</a> 单项数据流</h2> <ol><li>组件间 props 是只读的，自顶向下，流向单一。</li> <li>数据改变驱动视图改变，而视图变化需要手动更新状态</li></ol> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p><img src="/assets/img/lifeCycle.cac7e5e5.png" alt="LifeCycle">
错误处理：<br>
static getDerivedStateFromError(error) render 阶段，不可有副作用<br>
componentDidCatch() commit 阶段，可有副作用<br>
componentDidUpdate 与 useEffect 无依赖类似，每一次执行函数组件都会执行</p> <h3 id="getsnapshotbeforeupdate"><a href="#getsnapshotbeforeupdate" class="header-anchor">#</a> getSnapshotBeforeUpdate</h3> <p>获取更新前 DOM 信息的最佳时期，可进行和 dom 相关的计算
return 一个快照作为 componentDidUpdate 的第三个参数</p> <h3 id="useeffect-和-uselayouteffect-和-componentdidmount"><a href="#useeffect-和-uselayouteffect-和-componentdidmount" class="header-anchor">#</a> useEffect 和 useLayoutEffect 和 componentDidMount</h3> <p>useEffect 在 commit 阶段的 layout 子阶段结束后异步调用（渲染后调用）<br>
componentDidMount 和 useLayoutEffect：commit 的 layout 阶段同步调用（渲染前调用）</p> <h2 id="_15vs16"><a href="#_15vs16" class="header-anchor">#</a> 15vs16</h2> <h3 id="更新过程"><a href="#更新过程" class="header-anchor">#</a> 更新过程</h3> <p>15：同步不可中断</p> <ul><li>Reconciler（协调器）—— 负责找出变化的组件</li> <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上。递归处理虚拟 DOM。</li></ul> <p>16：异步可中断</p> <ul><li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler<br>
模拟 requestIdleCallback。不直接使用的原因：浏览器兼容性；触发频率不稳定（切换 tab）。</li> <li>Reconciler（协调器）—— 负责找出变化的组件<br>
调用 shouldYield，判断是否有剩余时间，标记有改变的虚拟 dom</li> <li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li></ul> <h2 id="fiber"><a href="#fiber" class="header-anchor">#</a> Fiber</h2> <h3 id="fiber-节点-动态工作单元"><a href="#fiber-节点-动态工作单元" class="header-anchor">#</a> fiber 节点——动态工作单元</h3> <p>ReactElement —— reconciler ——&gt; fiber<br>
14 中 fiber 类型，关系有三种：child，return，sibling</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> FunctionComponent <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 函数组件</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ClassComponent <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 类组件</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> IndeterminateComponent <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 初始化的时候不知道是函数组件还是类组件</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostRoot <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// Root Fiber 可以理解为根元素 ， 通过reactDom.render()产生的根元素</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostPortal <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 对应  ReactDOM.createPortal 产生的 Portal</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostComponent <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// dom 元素 比如 &lt;div&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostText <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// 文本节点</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Fragment <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">// 对应 &lt;React.Fragment&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Mode <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">// 对应 &lt;React.StrictMode&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ContextConsumer <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token comment">// 对应 &lt;Context.Consumer&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ContextProvider <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 对应 &lt;Context.Provider&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ForwardRef <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">// 对应 React.ForwardRef</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Profiler <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment">// 对应 &lt;Profiler/ &gt;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> SuspenseComponent <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span> <span class="token comment">// 对应 &lt;Suspense&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> MemoComponent <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">;</span> <span class="token comment">// 对应 React.memo 返回的组件</span>
</code></pre></div><h3 id="fiber-架构"><a href="#fiber-架构" class="header-anchor">#</a> fiber 架构</h3> <p>双缓存：在内存中构建，直接替换<br>
特点：更新可中断可继续，可设置优先级<br>
fiber——纤程，理解为协程的一种实现，js 中协程的实现：generator<br>
不使用 generator 的原因：</p> <ul><li>有传染性，当某个函数变为 generator 后，该函数调用链上的其他函数会有影响</li> <li>无法实现优先级。Generator 执行的中间状态是上下文关联的。</li></ul> <p>首次调用 ReactDOM.render——创建 FiberRootNode(整个应用的根节点)<br>
             ↓ current Fiber 树(当前页面内容)<br>
之后调用 ReactDOM.render——创建 RootFiber(当前应用的根节点)</p> <h3 id="首屏渲染、更新区别"><a href="#首屏渲染、更新区别" class="header-anchor">#</a> 首屏渲染、更新区别</h3> <p>首屏渲染与更新的区别，首屏渲染创建 fiber 树的过程没有 diff 算法<br>
对于两棵树都存在的 fiber 节点用 alternate 属性连接<br>
若 rootFiber 有 alternate 指向，则会基于该指向树创建 workInProgress Fiber 树。<br>
将 alternate 指向的 current fiber 和当前返回的 jsx 结构做对比，生成 workInProgress Fiber 树的过程就是进行<code>diff算法</code>。<br>
workInProgress Fiber 树 commit 后成为 FiberRootNode 的 current 指向，即变成 current 树。</p> <h3 id="context"><a href="#context" class="header-anchor">#</a> Context</h3> <h4 id="createcontext"><a href="#createcontext" class="header-anchor">#</a> createContext</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_CONTEXT_TYPE</span><span class="token punctuation">,</span>
  _currentValue<span class="token operator">:</span> defaultValue<span class="token punctuation">,</span>
  Provider<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  Consumer<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span>Provider <span class="token operator">=</span> <span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_PROVIDER_TYPE</span><span class="token punctuation">,</span>
  _context<span class="token operator">:</span> context<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span>Consumer <span class="token operator">=</span> <span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_CONTEXT_TYPE</span><span class="token punctuation">,</span>
  _context<span class="token operator">:</span> context<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="强制重新渲染"><a href="#强制重新渲染" class="header-anchor">#</a> 强制重新渲染</h3> <ol><li>forceUpdate：<br>
如果组件调用 forceUpdate,则全局的 hasForceUpdate=true，组件更新前检查如果为 true，则跳过 PureComponent 的浅比较和 shouldComponentUpdate 自定义比较，直接更新</li> <li>context 的更新</li></ol> <h3 id="suspense"><a href="#suspense" class="header-anchor">#</a> Suspense</h3> <p>Suspense 在执行内部可以通过 try{}catch{} 方式捕获异常，这个异常通常是一个 Promise ，可以在这个 Promise 中进行数据请求工作，Suspense 内部会处理这个 Promise ，Promise 结束后，Suspense 会再一次重新 render 把数据渲染出来，达到异步渲染的效果。</p> <h3 id="dangerouslysetinnerhtml"><a href="#dangerouslysetinnerhtml" class="header-anchor">#</a> dangerouslySetInnerHTML</h3> <p>dangerouslySetInnerHTML 是 React 为浏览器 DOM 提供 innerHTML 的替换方案。直接设置 HTML 存在风险(xss 攻击)。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div dangerouslySetInnerHTML<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> __html<span class="token operator">:</span> <span class="token string">'&lt;a href=&quot;&quot;&gt;跳转&lt;/a&gt;'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre></div><p>内容不能包含 react 组件，如果包含，需要用 ReactDom.render 包裹渲染</p> <h3 id="diff-算法"><a href="#diff-算法" class="header-anchor">#</a> diff 算法</h3> <p>对比更新前后的 nodeList,为 node 标记 flag,需要考虑是以下三种情况的哪种情况：</p> <ol><li>节点增删</li> <li>节点属性变化</li> <li>节点位置移动</li></ol> <p>三种情况的处理逻辑不同，情况 1&amp;2 属于常见情况，3 不常见。<br>
经历多轮遍历，优先处理常见情况，后处理不常见情况。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 虚拟dom节点数据结构</span>
type flag <span class="token operator">=</span> <span class="token string">&quot;Placement&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;Deletion&quot;</span><span class="token punctuation">;</span> <span class="token comment">//Placement新增或移动，Deletion删除</span>
<span class="token keyword">interface</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
  key<span class="token operator">:</span> string<span class="token punctuation">;</span> <span class="token comment">//node的唯一标识</span>
  flag<span class="token operator">?</span><span class="token operator">:</span> Flag<span class="token punctuation">;</span> <span class="token comment">// 标记操作类型</span>
  index<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">;</span> <span class="token comment">//该node在同级node中的索引位置</span>
<span class="token punctuation">}</span>

type NodeList <span class="token operator">=</span> Node<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">diff</span><span class="token punctuation">(</span><span class="token parameter">before<span class="token operator">:</span> NodeList<span class="token punctuation">,</span> after<span class="token operator">:</span> NodeList</span><span class="token punctuation">)</span><span class="token operator">:</span> NodeList <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result<span class="token operator">:</span>NodeList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 遍历前准备工作</span>
  <span class="token comment">// 1.需要存一份beforeNode,且以O(1)复杂度就能找到对应的node</span>
  <span class="token keyword">const</span> beforeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>string<span class="token punctuation">,</span>Node<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  before<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span>i</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    node<span class="token punctuation">.</span>index<span class="token operator">=</span>i<span class="token punctuation">;</span>
    beforeMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.遍历after,对比before，after，都存在的node，可复用，将存在两种情况：移动、不移动，如何判断？</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>after<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 遍历逻辑</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>demo1:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 更新前</span>
<span class="token keyword">const</span> before <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 更新后</span>
<span class="token keyword">const</span> after <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">&quot;d&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">diff</span><span class="token punctuation">(</span>before<span class="token punctuation">,</span> after<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
[
  {key:'a',flag:&quot;Deletion&quot;},
  {key:'d',flag:&quot;Placement&quot;}
]
*/</span>
</code></pre></div><p>demo2:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 更新前</span>
<span class="token keyword">const</span> before <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>key<span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>key<span class="token operator">:</span> <span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>key<span class="token operator">:</span> <span class="token string">'c'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
<span class="token comment">// 更新后</span>
<span class="token keyword">const</span> after <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>key<span class="token operator">:</span> <span class="token string">'c'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>key<span class="token operator">:</span> <span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>key<span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span>
<span class="token punctuation">]</span>

<span class="token function">diff</span><span class="token punctuation">(</span>before<span class="token punctuation">,</span> after<span class="token punctuation">)</span> 输出
<span class="token comment">/*
[
  {key: &quot;b&quot;, flag: &quot;Placement&quot;},
  {key: &quot;a&quot;, flag: &quot;Placement&quot;}
]

由于b之前已经存在，{key: &quot;b&quot;, flag: &quot;Placement&quot;}代表b对应DOM需要向后移动（对应parentNode.appendChild方法）。abc经过该操作后变为acb。

由于a之前已经存在，{key: &quot;a&quot;, flag: &quot;Placement&quot;}代表a对应DOM需要向后移动。acb经过该操作后变为cba。

执行后的结果就是：页面中的abc变为cba。
*/</span>
</code></pre></div><p>未完...</p> <h2 id="hooks"><a href="#hooks" class="header-anchor">#</a> Hooks</h2> <h3 id="代数效应"><a href="#代数效应" class="header-anchor">#</a> 代数效应</h3> <p>hooks 思想：将副作用从函数中分离，使函数功能纯粹。</p> <h3 id="useeffect"><a href="#useeffect" class="header-anchor">#</a> useEffect</h3> <p>在 fiber 节点上维护了一个链表(memorizedState)，每个 hooks 都在对应的链表元素上存取数据，每个 hooks 有 mount 和 update 两个阶段。<br> <strong>areHookInputsEqual</strong>函数用来处理第二个参数：</p> <ul><li>当热更新的时候，就算依赖没有变，也需要重新执行 effect，这个是通过 ignorePreviousDependencies 变量来控制的。</li> <li>deps 与上一个 deps 最对比，不一样则返回 false，触发更新，如果 prevDeps 是 null，直接返回 false，因此 useEffect 第二个参数传 undefined 或者 null 的话 effect 函数都会执行。</li></ul> <h3 id="usecallback-和-usememo-区别"><a href="#usecallback-和-usememo-区别" class="header-anchor">#</a> useCallback 和 useMemo 区别</h3> <p>useCallback 缓存第一个参数；<br>
useMemo 执行第一个参数，缓存其结果。</p> <h2 id="react-中的性能优化"><a href="#react-中的性能优化" class="header-anchor">#</a> React 中的性能优化</h2> <h3 id="性能优化原则"><a href="#性能优化原则" class="header-anchor">#</a> 性能优化原则：</h3> <p>当父组件满足性能优化条件(state 不变--&gt;props 不变) eagerState 策略<br>
子孙组件可能命中性能优化(子组件的 state&amp;context 不变时命中) bailout 策略<br>
三者都不变则不会重新渲染</p> <h4 id="如何比较-props-是否改变"><a href="#如何比较-props-是否改变" class="header-anchor">#</a> 如何比较 props 是否改变</h4> <ul><li>全等比较 高效，但不易命中 （react 默认）O(1)</li> <li>浅比较 遍历对象 key/value 不高效，但易命中 （memo）O(n)</li></ul> <p>为什么父组件 states 变子组件 props 就一定改变?<br>
因为子组件 props 永远是一个新的{}，{}!=={}<br>
根组件的 props 永远不变。</p> <p>react 重新渲染会重新构建整棵树，递归遍历每个节点，每次访问节点都会有两个回调：<br>
递：每次访问节点会调用 <code>beginWork</code>，处理 newProps 和 oldProps 的对比等<br>
归：直至访问到没有子节点的组件，则向上回归，依次调用 <code>completeWork</code></p> <h3 id="不使用-api"><a href="#不使用-api" class="header-anchor">#</a> 不使用 api</h3> <p>把变的部分和不变的部分分离（props,state,context）</p> <ul><li>拆分为两个组件</li> <li>不必重新渲染组件放在 children 里</li></ul> <h3 id="相关-api"><a href="#相关-api" class="header-anchor">#</a> 相关 api</h3> <h4 id="purecomponent"><a href="#purecomponent" class="header-anchor">#</a> PureComponent</h4> <p>浅比较 state 和 props 是否相等；
shouldComponentUpdate 的权重，大于 PureComponent；
更新阶段对 state 和 props 的比较，用了 <em>shallowEqual</em> 函数：</p> <ol><li>判断新老 state/props 是否相等</li> <li>新老 state/props 是否为非对象/null</li> <li>新老 state/props 的 keys 长度是否相等</li> <li>遍历老 state/props，对比对应新 state/props 的值是否相等</li></ol> <h4 id="react-memo"><a href="#react-memo" class="header-anchor">#</a> React.memo</h4> <p>是一个高阶组件</p> <div class="language-js extra-class"><pre class="language-js"><code>React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>Component<span class="token punctuation">,</span> compare<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// compare 返回true：缓存，false：更新</span>
<span class="token comment">// shouldComponentUpdate 返回true：更新，false：缓存</span>
<span class="token comment">// compare 不传-&gt;使用shallowEqual函数浅比较props</span>
</code></pre></div><h3 id="渲染控制"><a href="#渲染控制" class="header-anchor">#</a> 渲染控制</h3> <p><img src="/assets/img/renderControl.09225c1d.png" alt="RenderControl">
控制 render 的方法：</p> <ul><li>从父组件直接隔断子组件的渲染，经典的就是 memo，缓存 element 对象。</li> <li>组件从自身来控制是否 render ，比如：PureComponent ，shouldComponentUpdate。</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">11/30/2022, 10:39:48 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.6a1e7b57.js" defer></script><script src="/assets/js/2.f7f94fda.js" defer></script><script src="/assets/js/8.74f87bb3.js" defer></script>
  </body>
</html>
